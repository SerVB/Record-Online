/*
 * The MIT License
 *
 * Copyright 2017 SerVB.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
package recordonlineparser;

import jaco.mp3.player.MP3Player;
import java.io.IOException;
import java.net.MalformedURLException;
import java.net.URL;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.DefaultComboBoxModel;
import org.jsoup.Jsoup;
import org.jsoup.nodes.Document;
import org.jsoup.nodes.Element;
import org.jsoup.select.Elements;

/**
 *
 * @author SerVB
 */
public class ropUI extends javax.swing.JFrame {
    static ArrayList<RecordStream> RecordStreams = new ArrayList<>();
    final static String SITE = "http://air2.radiorecord.ru:805";
    static MP3Player mp = new MP3Player();
    static String[] cbList;
    static boolean onceUpdated = false;

    /**
     * Creates new form ropUI
     */
    public ropUI() {
        initComponents();

    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        jPanel1 = new javax.swing.JPanel();
        jLabelTextChoose = new javax.swing.JLabel();
        jComboBoxList = new javax.swing.JComboBox<>();
        jButtonReloadStreams = new javax.swing.JButton();
        jLabelTextLast = new javax.swing.JLabel();
        jLabelLast = new javax.swing.JLabel();
        jToggleButtonPlay = new javax.swing.JToggleButton();

        javax.swing.GroupLayout jPanel1Layout = new javax.swing.GroupLayout(jPanel1);
        jPanel1.setLayout(jPanel1Layout);
        jPanel1Layout.setHorizontalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );
        jPanel1Layout.setVerticalGroup(
            jPanel1Layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGap(0, 100, Short.MAX_VALUE)
        );

        setDefaultCloseOperation(javax.swing.WindowConstants.EXIT_ON_CLOSE);

        jLabelTextChoose.setText("Выбор потока:");

        jComboBoxList.setMaximumRowCount(20);
        jComboBoxList.setModel(new javax.swing.DefaultComboBoxModel<>(new String[] { "Нет данных" }));

        jButtonReloadStreams.setText("Обновить потоки");
        jButtonReloadStreams.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jButtonReloadStreamsMouseClicked(evt);
            }
        });

        jLabelTextLast.setText("Последний поток:");

        jLabelLast.setText("недоступно");

        jToggleButtonPlay.setText("Play");
        jToggleButtonPlay.addMouseListener(new java.awt.event.MouseAdapter() {
            public void mouseClicked(java.awt.event.MouseEvent evt) {
                jToggleButtonPlayMouseClicked(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(getContentPane());
        getContentPane().setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addComponent(jToggleButtonPlay, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(jButtonReloadStreams, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabelTextChoose)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jComboBoxList, 0, 301, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabelTextLast)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                        .addComponent(jLabelLast, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)))
                .addContainerGap())
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(jButtonReloadStreams)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelTextChoose)
                    .addComponent(jComboBoxList, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(jLabelTextLast)
                    .addComponent(jLabelLast))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jToggleButtonPlay)
                .addContainerGap(javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
        );

        pack();
    }// </editor-fold>//GEN-END:initComponents

    private void jButtonReloadStreamsMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jButtonReloadStreamsMouseClicked
        try {
            reload(); // Обновление данных с сайта
        } catch (IOException ex) {
            Logger.getLogger(ropUI.class.getName()).log(Level.SEVERE, null, ex);
        }
//        num(); // Вывод данных в консоль
        updateList();
    }//GEN-LAST:event_jButtonReloadStreamsMouseClicked

    private void jToggleButtonPlayMouseClicked(java.awt.event.MouseEvent evt) {//GEN-FIRST:event_jToggleButtonPlayMouseClicked
        if(onceUpdated) { // Проверка на наличие потока для проигрывания
            if(jToggleButtonPlay.isSelected()) { // Проигрывание
                int index = jComboBoxList.getSelectedIndex();
                String url = "";
                for(RecordStream rs:RecordStreams) {
                    if(rs.visualName.equals(cbList[index])) {
                        url = rs.fullPath;
                        break;
                    }
                }
                mp.stop();
                mp = new MP3Player();
                try {
                    mp.addToPlayList(new URL(url));
                } catch (MalformedURLException ex) {
                    Logger.getLogger(ropUI.class.getName()).log(Level.SEVERE, null, ex);
                }
                jLabelLast.setText(url);
                mp.play();
                jToggleButtonPlay.setText("Playing, click to stop");
            }
            else { // Остановка
                mp.stop();
                jToggleButtonPlay.setText("Play");
            }
        }
    }//GEN-LAST:event_jToggleButtonPlayMouseClicked

    /**
     * @param args the command line arguments
     * @throws java.lang.InterruptedException
     */
    public static void main(String args[]) throws InterruptedException {
        /* Set the Nimbus look and feel */
        //<editor-fold defaultstate="collapsed" desc=" Look and feel setting code (optional) ">
        /* If Nimbus (introduced in Java SE 6) is not available, stay with the default look and feel.
         * For details see http://download.oracle.com/javase/tutorial/uiswing/lookandfeel/plaf.html
         */
        try {
            for (javax.swing.UIManager.LookAndFeelInfo info : javax.swing.UIManager.getInstalledLookAndFeels()) {
                if ("Nimbus".equals(info.getName())) {
                    javax.swing.UIManager.setLookAndFeel(info.getClassName());
                    break;
                }
            }
        } catch (ClassNotFoundException | InstantiationException | IllegalAccessException | javax.swing.UnsupportedLookAndFeelException ex) {
            java.util.logging.Logger.getLogger(ropUI.class.getName()).log(java.util.logging.Level.SEVERE, null, ex);
        }
        //</editor-fold>

        //</editor-fold>

        /* Create and display the form */
        new ropUI().setVisible(true);
        //reload(); // Обновление данных с сайта
        //out(); // Вывод данных в консоль
//        /* Начало инициализации FX */
//        final CountDownLatch latch = new CountDownLatch(1);
//        SwingUtilities.invokeLater(() -> {
//            new JFXPanel(); // initializes JavaFX environment
//            latch.countDown();
//        });
//        latch.await();
//        /* Конец инициализации FX */
    }

    private static void reload() throws IOException { // Обновление данных с сайта
        System.out.println("reload() started!");
        long ml = System.currentTimeMillis(); // Время запуска функции
        RecordStreams.clear();
        String sSite = "http://air2.radiorecord.ru:805/status.xsl"; // Путь к html файлу (http://air2.radiorecord.ru:805/status.xsl)
        Document doc = Jsoup.parse(new URL(sSite), 10000); // Разбор html
        Elements elems = doc.getElementsByClass("newscontent"); // Поиск всех элементов с классом newscontent (Блок с названием потока и его свойствами)
        int corruptedStreams = 0;
        for(Element elem:elems) { // Проход по всем элементам
            RecordStream rs = new RecordStream(); // Временная структура для считывания
            rs.isComplete = true;
            if(elem.getElementsByTag("h3").isEmpty()) { // Проверка на безымянность потока
//                System.err.println("Unnamed stream #" + addedStreams + "!");
//                rs.isComplete = false; // Пометка нецелостности
                corruptedStreams++;
                continue; // Поток поврежден - пропуск потока
            }
            else {
                /* Вытаскивание относительного пути из заголовка: */
                ArrayList<String> strs = new ArrayList<>(Arrays.asList(elem.getElementsByTag("h3").first().text().split(" "))); // Разделение заголовка на слова
                String str = "";
                for(int i = strs.size()-1; i >= 0; i--) // Взятие относительного пути из последнего непустого слова
                    if(!(str = strs.get(i)).equals(""))
                        break;
                rs.relPath = str; // Запись относительного пути потока в структуру
                rs.fullPath = SITE + str; // Запись полного пути потока в структуру
            }
            Elements data = elem.getElementsByClass("streamdata"); // Выбор блоков с данными
            if(data.size()<10) { // Проверка на недостаточное кол-во свойств
//                System.err.println("Not enough data in the stream #" + addedStreams + "!");
//                rs.isComplete = false; // Пометка нецелостности
                corruptedStreams++;
                continue; // Поток поврежден - пропуск потока
            }
            else { // Присвоение свойств структуре:
                rs.streamTitle = data.get(0).text(); // Stream Title
                rs.streamDescr = data.get(1).text(); // Stream Descrition
                rs.contentType = data.get(2).text(); // Content Type
                rs.mountStart = data.get(3).text(); // Mount Start
                rs.bitrate = Integer.parseInt(data.get(4).text()); // Bitrate
                rs.curListeners = Integer.parseInt(data.get(5).text()); // Current Listeners
                rs.peakListeners = Integer.parseInt(data.get(6).text()); // Peak Listeners
                rs.streamGenre = data.get(7).text(); // Stream Genre
                rs.streamURL = data.get(8).text(); // Stream URL
                rs.curSong = data.get(9).text(); // Current Song
            }
            RecordStreams.add(rs); // Добавление потока
        }
        System.out.println(corruptedStreams + " corrupted streams detected");
        System.out.println(RecordStreams.size() + " valid streams were found");
        cleanStreams(); // Чистка потоков формата aac
        genVisualNames(); // Генерация названий для отображения
        onceUpdated = true;
        System.out.println("reload() finished in " + (System.currentTimeMillis()-ml) + " ms!");
    }

    private static void cleanStreams() { // Чистка потоков формата aac
        System.out.println("cleanStreams() started!");
        long ml = System.currentTimeMillis(); // Время запуска функции
        for(int i = 0; i < RecordStreams.size(); i++) {
            if(!RecordStreams.get(i).contentType.toLowerCase().contains("mpeg")) {
                RecordStreams.remove(i);
                i--;
            }
        }
        System.out.println("It is possible to play " + RecordStreams.size() + " streams");
        System.out.println("cleanStreams() finished in " + (System.currentTimeMillis()-ml) + " ms!");
    }

    private static void genVisualNames() { // Генерация названий для отображения
        System.out.println("genVisualNames() started!");
        long ml = System.currentTimeMillis(); // Время запуска функции
        final String[][] equal =
           {{"brks","Record Breaks"},
            {"chil","Record Chillout Radio"},
            {"club","Record Club Radio"},
            {"dc","Record Dancecore"},
            {"deep","Record Deep Radio"},
            {"dub","Record Dubstep"},
            {"fut","Record Future"},
            {"gop","GOP FM"},
            {"mdl","Medlyak FM"},
            {"mini","Record MINIMAL"},
            {"mix","Record MEGAMIX"},
            {"ps","Pirate Station Radio"},
            {"pump","Record Pump'n'Klubb"},
            {"rave","Record Rave"},
            {"rock","Rock Radio"},
            {"rr","RADIO RECORD"},
            {"rus","Record Russian Mix"},
            {"sd90","Superdiscoteka 90's"},
            {"techno","Record Techno"},
            {"teo","Teodor Radio"},
            {"tm","Trancemission Radio"},
            {"trap","Record Trap"},
            {"vip","Vip Mix Radio"},
            {"yo","YO FM"}};
        final int eqLen = 24; // Количество соответствий // equal.size()
        for(int i = 0; i < RecordStreams.size(); i++) {
            RecordStreams.get(i).visualName = RecordStreams.get(i).relPath.substring(1); // Установка показываемого имени на относительный путь без слеша
            String miniName = RecordStreams.get(i).relPath.toLowerCase();
            for(int j = 0; j < eqLen; j++) { // Поиск соответствия
                if(miniName.contains(equal[j][0])) {
                    RecordStreams.get(i).visualName = equal[j][1] + " " + RecordStreams.get(i).bitrate + " kbps";
                    break;
                }
            }
        }
        System.out.println("genVisualNames() finished in " + (System.currentTimeMillis()-ml) + " ms!");
    }

    private static int num() { // Вычисление кол-ва неиспорченных потоков
        System.out.println("num() started!");
        long ml = System.currentTimeMillis(); // Время запуска функции
        int size = RecordStreams.size();
        int num = 0;
        for(int i = 0; i < size; i++) {
            RecordStream rs = RecordStreams.get(i);
            if(rs.isComplete) {
//                System.out.println(String.format("%3d: %-25s %s", i, rs.streamTitle, rs.fullPath));
                num++;
            }
        }
//        System.out.println("There are " + num + " valid streams");
        System.out.println("num() finished in " + (System.currentTimeMillis()-ml) + " ms!");
        return num;
    }

    private void updateList() { // Обновление jComboBox
        System.out.println("updateList() started!");
        long ml = System.currentTimeMillis(); // Время запуска функции
        int numOfStreams = num();
        cbList = new String[numOfStreams];
        int cur = 0;
        for(int i = 0; i < RecordStreams.size(); i++) {
            if(RecordStreams.get(i).isComplete) {
                cbList[cur] = RecordStreams.get(i).visualName;
                cur++;
            }
        }
        DefaultComboBoxModel model = new DefaultComboBoxModel(cbList);
        jComboBoxList.setModel(model);
        System.out.println("updateList() finished in " + (System.currentTimeMillis()-ml) + " ms!");
    }

    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton jButtonReloadStreams;
    private javax.swing.JComboBox<String> jComboBoxList;
    private javax.swing.JLabel jLabelLast;
    private javax.swing.JLabel jLabelTextChoose;
    private javax.swing.JLabel jLabelTextLast;
    private javax.swing.JPanel jPanel1;
    private javax.swing.JToggleButton jToggleButtonPlay;
    // End of variables declaration//GEN-END:variables
}

class RecordStream {
    public String relPath;
    public String fullPath;
    public String streamTitle;
    public String streamDescr;
    public String contentType;
    public String mountStart;
    public int bitrate;
    public int curListeners;
    public int peakListeners;
    public String streamGenre;
    public String streamURL;
    public String curSong;
    public boolean isComplete;
    public String visualName;

    public RecordStream() {
        this.relPath = null;
        this.fullPath = null;
        this.streamTitle = null;
        this.streamDescr = null;
        this.contentType = null;
        this.mountStart = null;
        this.bitrate = -1;
        this.curListeners = -1;
        this.peakListeners = -1;
        this.streamGenre = null;
        this.streamURL = null;
        this.curSong = null;
        this.isComplete = false;
        this.visualName = null;
    }
}